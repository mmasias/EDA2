@startuml jerarquiaTecnicas

hide empty members
hide circle
skinparam linetype polyline

class M_I <<Iterativo + Mutable>> {
    **Patrón dominante**
    ----
    • Bucles con índices
    • Modificación in-situ
    • Arrays mutables
    ----
    Ejemplo:
    Burbuja, Inserción, Heapsort    
}

class M_R <<Recursivo + Mutable>> {
    **Patrón híbrido**
    ----
    • Recursión con efectos
    • Modificación durante el retroceso
    ----
    Ejemplo:
    Quicksort in-place    
}

class I_I <<Iterativo + Inmutable>> {
    **Patrón funcional**
    ----
    • Bucles con acumulador
    • Copia en cada paso
    • Estructuras persistentes
    ----
    Ejemplo: fold/reduce
    sobre listas inmutables
}

class I_R <<Recursivo + Inmutable>> {
    **Patrón puramente funcional**
    ----
    • Recursión sin efectos
    • Nuevas estructuras en cada llamada
    ----
    Ejemplo: Mergesort funcional,
    map/filter
}

class "Algoritmo general" as General {
    Entrada → Transformación → Salida
}

class "Iterativo" as Iter {
    Estado explícito
    Flujo secuencial
}

class "Recursivo" as Rec {
    Estado implícito en pila
    Flujo compositivo
}

class "Mutable" as Mut {    
    Modificación directa
    Eficiencia espacial
}

class "Inmutable" as Inmut {
    Transformaciones puras
    Razonamiento composicional
}

General -right-> Iter : "¿Cómo se gestiona\nel flujo?"
General -left-> Rec : "¿Cómo se gestiona\nel flujo?"
General -up-> Mut : "¿Cómo se gestiona\nel estado?"
General -down-> Inmut : "¿Cómo se gestiona\nel estado?"

Iter -up-> M_I
Mut -right-> M_I

Rec -up-> M_R
Mut -left-> M_R

Iter -down-> I_I
Inmut -right-> I_I

Rec -down-> I_R
Inmut -left-> I_R

@enduml