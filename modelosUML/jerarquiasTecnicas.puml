@startuml jerarquiaTecnicas

hide empty members
hide circle
hide stereotypes

skinparam class {
    FontSize 12
}

skinparam class<<cuadrante>> {
    BorderThickness 1
}

skinparam class<<eje>> {
    BorderThickness 2
}

skinparam class<<nucleo>> {
    BorderThickness 3
}

class M_I as "**Patrón dominante**" <<cuadrante>> {
    <size:11>Iterativo + Mutable
    ----
    <size:10>• Bucles con índices
    <size:10>• Modificación in-situ
    <size:10>• Arrays mutables
    ----
    <size:10>Ejemplo:
    <size:10>Burbuja, Inserción, Heapsort
}

class M_R as "**Patrón híbrido**" <<cuadrante>> {
    <size:11>Recursivo + Mutable
    ----
    <size:10>• Recursión con efectos
    <size:10>• Modificación durante el retroceso
    ----
    <size:10>Ejemplo:
    <size:10>Quicksort in-place
}

class I_I as "**Patrón funcional**" <<cuadrante>> {
    <size:11>Iterativo + Inmutable
    ----
    <size:10>• Bucles con acumulador
    <size:10>• Copia en cada paso
    <size:10>• Estructuras persistentes
    ----
    <size:10>Ejemplo: fold/reduce
    <size:10>sobre listas inmutables
}

class I_R as "**Patrón puramente funcional**" <<cuadrante>> {
    <size:11>Recursivo + Inmutable
    ----
    <size:10>• Recursión sin efectos
    <size:10>• Nuevas estructuras en cada llamada
    ----
    <size:10>Ejemplo: Mergesort funcional,
    <size:10>map/filter
}

class "Algoritmo general" as General <<nucleo>> {
    <size:13>Entrada → Transformación → Salida
}

class "Iterativo" as Iter <<eje>> {
    Estado explícito
    Flujo secuencial
}

class "Recursivo" as Rec <<eje>> {
    Estado implícito en pila
    Flujo compositivo
}

class "Mutable" as Mut <<eje>> {    
    Modificación directa
    Eficiencia espacial
}

class "Inmutable" as Inmut <<eje>> {
    Transformaciones puras
    Razonamiento composicional
}

General -right-> Iter : "¿Cómo se gestiona\nel flujo?"
General -left-> Rec : "¿Cómo se gestiona\nel flujo?"
General -up-> Mut : "¿Cómo se gestiona\nel estado?"
General -down-> Inmut : "¿Cómo se gestiona\nel estado?"

Iter -up-> M_I
Mut -right-> M_I

Rec -up-> M_R
Mut -left-> M_R

Iter -down-> I_I
Inmut -right-> I_I

Rec -down-> I_R
Inmut -left-> I_R

@enduml