# Estructuras de datos y algoritmos II

## ¿Por qué?

Habiendo aprendido los fundamentos de la programación imperativa, estructurada y orientada a objetos (PRG1, PRG2); y luego de ver la manera de organizar la información en estructuras de datos eficientes (EDA1), **es pertinente abordar el siguiente paso: aprender a operar sobre esas estructuras de manera eficiente**.

No basta con que un programa funcione correctamente; es necesario que lo haga aprovechando óptimamente los recursos disponibles. Un algoritmo que resuelve un problema para cientos de elementos puede volverse inusable cuando la entrada crece a millones.

## ¿Qué?

La algorítmica es la disciplina que estudia los métodos para resolver problemas de manera sistemática y eficiente. A diferencia de lo visto en asignaturas anteriores, donde el foco estaba en **cómo organizar el código** (PRG1, PRG2) o **cómo organizar los datos** (EDA1), en EDA2 el foco está en **cómo operar sobre esos datos organizados**.

<div align=center>

|PRG1|PRG2|EDA1|EDA2|
|-|-|-|-|
|***Fundamentos mecánicos***|***Expansión conceptual***|***Restricción disciplinada***|***Aplicación algorítmica***
|Cómo hacer que la máquina haga X|Se puede modelar cualquier cosa|No todo objeto es igual: algunos son más eficientes para ciertos usos|Ahora que conocemos las herramientas, usémoslas con eficiencia
|Variables, control de flujo, funciones|Abstracción mediante objetos|Las abstracciones tienen coste|Dada la estructura correcta, ¿cómo la uso óptimamente?
|Pensamiento secuencial|Encapsulación, herencia, polimorfismo|Cada estructura garantiza propiedades específicas|Ordenar, buscar, transformar con garantías de complejidad
||Libertad de diseño|Elección deliberada: pila vs. cola vs. árbol|

</div>

<div align=center>

![](/images/modelosUML/jerarquiaTecnicas.svg)

</div>

## ¿Para qué?

- **Capacidad de análisis:** Evaluar si un algoritmo es viable para el problema en cuestión. Distinguir entre algo aceptable para 100 elementos vs. inviable para 1.000.000.
- **Selección informada:** Elegir la técnica correcta según el contexto.
- **Optimización justificada:** Identificar cuándo vale la pena optimizar. No todo código necesita ser optimizado: algunos problemas se resuelven adecuadamente con soluciones simples.
- **Fundamento para especialización:** Base conceptual para cursos avanzados (programación funcional, programación dinámica, teoría de grafos, machine learning) donde la eficiencia algorítmica es crítica.

## ¿Cómo?

### [Temario](/temario/README.md)

- [ ] [Algoritmos++](temario/001-algoritmosPlus/README.md)
- [ ] [Recursividad](temario/002-recursividad/README.md)
- [ ] [Ordenación](temario/003-ordenacion/README.md)
- [ ] [Inmutabilidad](temario/004-inmutabilidad/README.md)
- [ ] [Hashing](temario/005-hashing/README.md)
- [ ] [Búsquedas](temario/006-busquedas/README.md)
- [ ] [Estructuras de datos++](temario/007-estructurasDatosPlus/README.md)